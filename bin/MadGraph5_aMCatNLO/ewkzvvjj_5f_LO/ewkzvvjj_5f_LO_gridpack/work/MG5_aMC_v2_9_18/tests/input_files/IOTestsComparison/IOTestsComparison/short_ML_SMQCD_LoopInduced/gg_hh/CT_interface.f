      SUBROUTINE CTLOOP(NLOOPLINE,PL,M2L,RANK,RES,STABLE)
C     
C     Generated by MadGraph5_aMC@NLO v. %(version)s, %(date)s
C     By the MadGraph5_aMC@NLO Development Team
C     Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
C     
C     Interface between MG5 and CutTools.
C     
C     Process: g g > h h QED=2 QCD=2 [ virt = QCD ] WEIGHTED=12
C     
C     
C     CONSTANTS 
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=4)
      LOGICAL CHECKPCONSERVATION
      PARAMETER (CHECKPCONSERVATION=.TRUE.)
      REAL*8 NORMALIZATION
      PARAMETER (NORMALIZATION = 1.D0/(16.D0*3.14159265358979323846D0*
     $ *2))
C     
C     ARGUMENTS 
C     
      INTEGER NLOOPLINE, RANK
      REAL*8 PL(0:3,NLOOPLINE)
      REAL*8 PCT(0:3,0:NLOOPLINE-1)
      COMPLEX*16 M2L(NLOOPLINE)
      COMPLEX*16 M2LCT(0:NLOOPLINE-1)
      COMPLEX*16 RES(3)
      LOGICAL STABLE
C     
C     LOCAL VARIABLES 
C     
      COMPLEX*16 R1, ACC
      INTEGER I, J, K
      LOGICAL INIT
      DATA INIT /.TRUE./
      SAVE INIT
C     
C     EXTERNAL FUNCTIONS
C     
      EXTERNAL LOOPNUM
      EXTERNAL MPLOOPNUM
C     
C     GLOBAL VARIABLES
C     
      INCLUDE 'coupl.inc'
      INTEGER CTMODE
      REAL*8 LSCALE
      COMMON/CT/LSCALE,CTMODE

      INTEGER WE(NEXTERNAL)
      INTEGER ID, SYMFACT, AMPLNUM
      COMMON/LOOP/WE,ID,SYMFACT, AMPLNUM

C     ----------
C     BEGIN CODE
C     ----------

C     INITIALIZE CUTTOOLS IF NEEDED
      IF (INIT) THEN
        INIT=.FALSE.
        CALL INITCT()
      ENDIF

C     YOU CAN FIND THE DETAILS ABOUT THE DIFFERENT CTMODE AT THE
C      BEGINNING OF THE FILE CTS_CUTS.F90 IN THE CUTTOOLS DISTRIBUTION

C     CONVERT THE MASSES TO BE COMPLEX
      DO I=1,NLOOPLINE
        M2LCT(I-1)=M2L(I)
      ENDDO

C     CONVERT THE MOMENTA FLOWING IN THE LOOP LINES TO CT CONVENTIONS
      DO I=0,3
        DO J=0,(NLOOPLINE-1)
          PCT(I,J)=0.D0
        ENDDO
      ENDDO
      DO I=0,3
        DO J=1,NLOOPLINE
          PCT(I,0)=PCT(I,0)+PL(I,J)
        ENDDO
      ENDDO
      IF (CHECKPCONSERVATION) THEN
        IF (PCT(0,0).GT.1.D-6) THEN
          WRITE(*,*) 'energy is not conserved ',PCT(0,0)
          STOP 'energy is not conserved'
        ELSEIF (PCT(1,0).GT.1.D-6) THEN
          WRITE(*,*) 'px is not conserved ',PCT(1,0)
          STOP 'px is not conserved'
        ELSEIF (PCT(2,0).GT.1.D-6) THEN
          WRITE(*,*) 'py is not conserved ',PCT(2,0)
          STOP 'py is not conserved'
        ELSEIF (PCT(3,0).GT.1.D-6) THEN
          WRITE(*,*) 'pz is not conserved ',PCT(3,0)
          STOP 'pz is not conserved'
        ENDIF
      ENDIF
      DO I=0,3
        DO J=1,(NLOOPLINE-1)
          DO K=1,J
            PCT(I,J)=PCT(I,J)+PL(I,K)
          ENDDO
        ENDDO
      ENDDO

      CALL CTSXCUT(CTMODE,LSCALE,MU_R,NLOOPLINE,LOOPNUM,MPLOOPNUM,RANK
     $ ,PCT,M2LCT,RES,ACC,R1,STABLE)
      RES(1)=NORMALIZATION*RES(1)
      RES(2)=NORMALIZATION*RES(2)
      RES(3)=NORMALIZATION*RES(3)
C     WRITE(*,*) 'Loop AMPLNUM',AMPLNUM,' =',RES(1),RES(2),RES(3)
      END

      SUBROUTINE INITCT()
C     
C     INITIALISATION OF CUTTOOLS
C     
C     LOCAL VARIABLES 
C     
      REAL*8 THRS
      LOGICAL EXT_NUM_FOR_R1
C     
C     GLOBAL VARIABLES 
C     
      INCLUDE 'MadLoopParams.inc'
C     ----------
C     BEGIN CODE
C     ----------

C     DEFAULT PARAMETERS FOR CUTTOOLS
C     -------------------------------  
C     THRS1 IS THE PRECISION LIMIT BELOW WHICH THE MP ROUTINES
C      ACTIVATES
      THRS=CTSTABTHRES
C     LOOPLIB SET WHAT LIBRARY CT USES
C     1 -> LOOPTOOLS
C     2 -> AVH
C     3 -> QCDLOOP
      LOOPLIB=CTLOOPLIBRARY
C     MADLOOP'S NUMERATOR IN THE DEFAULT OUTPUT IS SLOWER THAN THE
C      RECONSTRUCTED ONE IN CT. SO WE BETTER USE CT ONE IN THIS CASE.
      EXT_NUM_FOR_R1=.FALSE.
C     -------------------------------	  

C     The initialization below is for CT v1.8.+
      CALL CTSINIT(THRS,LOOPLIB,EXT_NUM_FOR_R1)
C     The initialization below is for the older stable CT v1.7, still
C      used for now in the beta release.
C     CALL CTSINIT(THRS,LOOPLIB)

      END

      SUBROUTINE LOOP_3_3( LID, W1, W2, W3, M1,MP_M1, M2,MP_M2, M3
     $ ,MP_M3, C1,MP_C1, C2,MP_C2, C3,MP_C3,  RANK, LSYMFACT, AMPLN
     $ , RES, STABLE)

      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=4)
      INTEGER    MAXLCOUPLINGS
      PARAMETER (MAXLCOUPLINGS=4)
      INTEGER    NLOOPLINE
      PARAMETER (NLOOPLINE=3)
      INTEGER    NWAVEFUNCS
      PARAMETER (NWAVEFUNCS=5)
      INTEGER    NCOMB
      PARAMETER (NCOMB=4)
C     
C     ARGUMENTS 
C     
      INTEGER W1, W2, W3
      COMPLEX*16 M1, M2, M3
      COMPLEX*32 MP_M1, MP_M2, MP_M3
      COMPLEX*16 C1, C2, C3
      COMPLEX*32 MP_C1, MP_C2, MP_C3

      COMPLEX*16 RES(3)
      INTEGER LID, RANK, LSYMFACT
      INTEGER AMPLN
      LOGICAL STABLE
C     
C     LOCAL VARIABLES 
C     
      REAL*8 PL(0:3,NLOOPLINE)
      COMPLEX*16 M2L(NLOOPLINE)
      INTEGER PAIRING(NLOOPLINE)
      INTEGER I, J, K, TEMP
C     
C     GLOBAL VARIABLES
C     
      INTEGER WE(NEXTERNAL)
      INTEGER ID, SYMFACT, AMPLNUM
      COMMON/LOOP/WE,ID,SYMFACT, AMPLNUM

      COMPLEX*16 LC(MAXLCOUPLINGS)
      COMPLEX*16 ML(NEXTERNAL+2)
      COMMON/DP_LOOP/LC,ML

      COMPLEX*32 MP_LC(MAXLCOUPLINGS)
      COMPLEX*32 MP_ML(NEXTERNAL+2)
      COMMON/MP_LOOP/MP_LC,MP_ML

      COMPLEX*16 W(20,NWAVEFUNCS)
      INTEGER VALIDH
      COMMON/WFCTS/W
      COMMON/VALIDH/VALIDH

C     ----------
C     BEGIN CODE
C     ----------

      WE(1)=W1
      WE(2)=W2
      WE(3)=W3
      M2L(1)=M3**2
      M2L(2)=M1**2
      M2L(3)=M2**2
      ML(1)=M3
      ML(2)=M3
      MP_ML(1)=MP_M3
      MP_ML(2)=MP_M3
      ML(3)=M1
      MP_ML(3)=MP_M1
      ML(4)=M2
      MP_ML(4)=MP_M2
      ML(5)=M3
      MP_ML(5)=MP_M3
      DO I=1,NLOOPLINE
        PAIRING(I)=1
      ENDDO

      LC(1)=C1
      MP_LC(1)=MP_C1
      LC(2)=C2
      MP_LC(2)=MP_C2
      LC(3)=C3
      MP_LC(3)=MP_C3
      AMPLNUM=AMPLN
      ID=LID
      SYMFACT=LSYMFACT
      DO I=0,3
        TEMP=1
        DO J=1,NLOOPLINE
          PL(I,J)=0.D0
          DO K=TEMP,(TEMP+PAIRING(J)-1)
            PL(I,J)=PL(I,J)-DBLE(W(1+I,WE(K)))
          ENDDO
          TEMP=TEMP+PAIRING(J)
        ENDDO
      ENDDO
      CALL CTLOOP(NLOOPLINE,PL,M2L,RANK,RES,STABLE)

      END

      SUBROUTINE LOOP_4_4( LID, W1, W2, W3, W4, M1,MP_M1, M2,MP_M2, M3
     $ ,MP_M3, M4,MP_M4, C1,MP_C1, C2,MP_C2, C3,MP_C3, C4,MP_C4,  RANK
     $ , LSYMFACT, AMPLN, RES, STABLE)

      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=4)
      INTEGER    MAXLCOUPLINGS
      PARAMETER (MAXLCOUPLINGS=4)
      INTEGER    NLOOPLINE
      PARAMETER (NLOOPLINE=4)
      INTEGER    NWAVEFUNCS
      PARAMETER (NWAVEFUNCS=5)
      INTEGER    NCOMB
      PARAMETER (NCOMB=4)
C     
C     ARGUMENTS 
C     
      INTEGER W1, W2, W3, W4
      COMPLEX*16 M1, M2, M3, M4
      COMPLEX*32 MP_M1, MP_M2, MP_M3, MP_M4
      COMPLEX*16 C1, C2, C3, C4
      COMPLEX*32 MP_C1, MP_C2, MP_C3, MP_C4

      COMPLEX*16 RES(3)
      INTEGER LID, RANK, LSYMFACT
      INTEGER AMPLN
      LOGICAL STABLE
C     
C     LOCAL VARIABLES 
C     
      REAL*8 PL(0:3,NLOOPLINE)
      COMPLEX*16 M2L(NLOOPLINE)
      INTEGER PAIRING(NLOOPLINE)
      INTEGER I, J, K, TEMP
C     
C     GLOBAL VARIABLES
C     
      INTEGER WE(NEXTERNAL)
      INTEGER ID, SYMFACT, AMPLNUM
      COMMON/LOOP/WE,ID,SYMFACT, AMPLNUM

      COMPLEX*16 LC(MAXLCOUPLINGS)
      COMPLEX*16 ML(NEXTERNAL+2)
      COMMON/DP_LOOP/LC,ML

      COMPLEX*32 MP_LC(MAXLCOUPLINGS)
      COMPLEX*32 MP_ML(NEXTERNAL+2)
      COMMON/MP_LOOP/MP_LC,MP_ML

      COMPLEX*16 W(20,NWAVEFUNCS)
      INTEGER VALIDH
      COMMON/WFCTS/W
      COMMON/VALIDH/VALIDH

C     ----------
C     BEGIN CODE
C     ----------

      WE(1)=W1
      WE(2)=W2
      WE(3)=W3
      WE(4)=W4
      M2L(1)=M4**2
      M2L(2)=M1**2
      M2L(3)=M2**2
      M2L(4)=M3**2
      ML(1)=M4
      ML(2)=M4
      MP_ML(1)=MP_M4
      MP_ML(2)=MP_M4
      ML(3)=M1
      MP_ML(3)=MP_M1
      ML(4)=M2
      MP_ML(4)=MP_M2
      ML(5)=M3
      MP_ML(5)=MP_M3
      ML(6)=M4
      MP_ML(6)=MP_M4
      DO I=1,NLOOPLINE
        PAIRING(I)=1
      ENDDO

      LC(1)=C1
      MP_LC(1)=MP_C1
      LC(2)=C2
      MP_LC(2)=MP_C2
      LC(3)=C3
      MP_LC(3)=MP_C3
      LC(4)=C4
      MP_LC(4)=MP_C4
      AMPLNUM=AMPLN
      ID=LID
      SYMFACT=LSYMFACT
      DO I=0,3
        TEMP=1
        DO J=1,NLOOPLINE
          PL(I,J)=0.D0
          DO K=TEMP,(TEMP+PAIRING(J)-1)
            PL(I,J)=PL(I,J)-DBLE(W(1+I,WE(K)))
          ENDDO
          TEMP=TEMP+PAIRING(J)
        ENDDO
      ENDDO
      CALL CTLOOP(NLOOPLINE,PL,M2L,RANK,RES,STABLE)

      END

